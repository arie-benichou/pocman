<html>
  <head>
    <title>Java Pretty Print</title>
  </head>
  <body style="font-family: monospace;">
<span style="color: teal">/******************************************************************************<br>&nbsp;*&nbsp;File:&nbsp;EdmondsMatching.java<br>&nbsp;*&nbsp;Author:&nbsp;Keith&nbsp;Schwarz&nbsp;(htiek@cs.stanford.edu)<br>&nbsp;*<br>&nbsp;*&nbsp;An&nbsp;implementation&nbsp;of&nbsp;Edmonds's&nbsp;Maximum&nbsp;Matching&nbsp;algorithm&nbsp;for&nbsp;general<br>&nbsp;*&nbsp;graphs.&nbsp;&nbsp;This&nbsp;algorithm&nbsp;is&nbsp;comparatively&nbsp;old&nbsp;-&nbsp;it&nbsp;dates&nbsp;back&nbsp;to&nbsp;1965&nbsp;-&nbsp;and<br>&nbsp;*&nbsp;is&nbsp;not&nbsp;particularly&nbsp;efficient&nbsp;compared&nbsp;to&nbsp;modern&nbsp;algorithms&nbsp;(it&nbsp;runs&nbsp;in<br>&nbsp;*&nbsp;O(n^2&nbsp;m),&nbsp;when&nbsp;O(sqrt(n)&nbsp;m)&nbsp;algorithms&nbsp;now&nbsp;exist).&nbsp;&nbsp;However,&nbsp;Edmonds's<br>&nbsp;*&nbsp;algorithm&nbsp;is&nbsp;extremely&nbsp;theoretically&nbsp;elegant&nbsp;and&nbsp;can&nbsp;be&nbsp;implemented&nbsp;easily<br>&nbsp;*&nbsp;using&nbsp;standard,&nbsp;off-the-shelf&nbsp;utility&nbsp;classes.<br>&nbsp;*<br>&nbsp;*&nbsp;The&nbsp;key&nbsp;concept&nbsp;powering&nbsp;Edmonds's&nbsp;algorithm&nbsp;is&nbsp;the&nbsp;notion&nbsp;of&nbsp;an&nbsp;alternating<br>&nbsp;*&nbsp;path.&nbsp;&nbsp;Given&nbsp;a&nbsp;graph&nbsp;and&nbsp;matching&nbsp;(G,&nbsp;M),&nbsp;consider&nbsp;any&nbsp;path&nbsp;P&nbsp;in&nbsp;G.&nbsp;&nbsp;Some&nbsp;of<br>&nbsp;*&nbsp;the&nbsp;edges&nbsp;in&nbsp;P&nbsp;will&nbsp;also&nbsp;be&nbsp;in&nbsp;M,&nbsp;while&nbsp;others&nbsp;will&nbsp;not&nbsp;be.&nbsp;&nbsp;Let's&nbsp;call&nbsp;an<br>&nbsp;*&nbsp;edge&nbsp;in&nbsp;the&nbsp;path&nbsp;that's&nbsp;also&nbsp;in&nbsp;M&nbsp;&quot;solid,&quot;&nbsp;while&nbsp;an&nbsp;edge&nbsp;in&nbsp;the&nbsp;path&nbsp;not&nbsp;in<br>&nbsp;*&nbsp;M&nbsp;&quot;dashed.&quot;&nbsp;&nbsp;A&nbsp;path&nbsp;is&nbsp;called&nbsp;alternating&nbsp;if&nbsp;the&nbsp;edges&nbsp;alternate&nbsp;between<br>&nbsp;*&nbsp;solid&nbsp;and&nbsp;dashed.&nbsp;&nbsp;For&nbsp;example,&nbsp;this&nbsp;path&nbsp;is&nbsp;alternating:<br>&nbsp;*<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;========&nbsp;*&nbsp;=&nbsp;=&nbsp;=&nbsp;=&nbsp;=&nbsp;*&nbsp;=========&nbsp;*&nbsp;=&nbsp;=&nbsp;=&nbsp;=&nbsp;=&nbsp;*<br>&nbsp;*<br>&nbsp;*&nbsp;As&nbsp;is&nbsp;this&nbsp;one:<br>&nbsp;*<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;=&nbsp;=&nbsp;=&nbsp;=&nbsp;=&nbsp;*&nbsp;=========&nbsp;*<br>&nbsp;*<br>&nbsp;*&nbsp;Note&nbsp;that&nbsp;this&nbsp;also&nbsp;means&nbsp;that&nbsp;a&nbsp;single&nbsp;edge&nbsp;is&nbsp;automatically&nbsp;an&nbsp;alternating<br>&nbsp;*&nbsp;path.<br>&nbsp;*<br>&nbsp;*&nbsp;The&nbsp;main&nbsp;theorem&nbsp;on&nbsp;which&nbsp;Edmonds's&nbsp;matching&nbsp;algorithm&nbsp;is&nbsp;based&nbsp;is&nbsp;the<br>&nbsp;*&nbsp;following:<br>&nbsp;*<br>&nbsp;*&nbsp;&quot;Given&nbsp;a&nbsp;matching&nbsp;(G,&nbsp;M),&nbsp;M&nbsp;is&nbsp;a&nbsp;maximum&nbsp;matching&nbsp;iff&nbsp;G&nbsp;contains&nbsp;no&nbsp;<br>&nbsp;*&nbsp;&nbsp;alternating&nbsp;paths&nbsp;between&nbsp;exposed&nbsp;vertices.&quot;<br>&nbsp;*<br>&nbsp;*&nbsp;There&nbsp;are&nbsp;several&nbsp;good&nbsp;proofs&nbsp;of&nbsp;this&nbsp;claim.&nbsp;&nbsp;One&nbsp;direction&nbsp;is&nbsp;easy&nbsp;-&nbsp;if&nbsp;the<br>&nbsp;*&nbsp;graph&nbsp;contains&nbsp;an&nbsp;alternating&nbsp;path&nbsp;between&nbsp;exposed&nbsp;vertices,&nbsp;then&nbsp;we&nbsp;can<br>&nbsp;*&nbsp;construct&nbsp;a&nbsp;larger&nbsp;matching&nbsp;by&nbsp;replacing&nbsp;the&nbsp;matched&nbsp;edges&nbsp;in&nbsp;the&nbsp;path&nbsp;with<br>&nbsp;*&nbsp;the&nbsp;unmatched&nbsp;edges.&nbsp;&nbsp;That&nbsp;is,&nbsp;we&nbsp;change<br>&nbsp;*<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;=&nbsp;=&nbsp;=&nbsp;=&nbsp;*&nbsp;=======&nbsp;*&nbsp;=&nbsp;=&nbsp;=&nbsp;=&nbsp;*&nbsp;=======&nbsp;*&nbsp;=&nbsp;=&nbsp;=&nbsp;=&nbsp;*<br>&nbsp;*<br>&nbsp;*&nbsp;into<br>&nbsp;*<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;=======&nbsp;*&nbsp;=&nbsp;=&nbsp;=&nbsp;=&nbsp;*&nbsp;=======&nbsp;*&nbsp;=&nbsp;=&nbsp;=&nbsp;=&nbsp;*&nbsp;=======&nbsp;*<br>&nbsp;*<br>&nbsp;*&nbsp;This&nbsp;matching&nbsp;has&nbsp;edge&nbsp;more&nbsp;than&nbsp;the&nbsp;previous&nbsp;matching,&nbsp;so&nbsp;M&nbsp;isn't&nbsp;maximum.<br>&nbsp;*&nbsp;The&nbsp;inverse&nbsp;direction&nbsp;is&nbsp;a&nbsp;bit&nbsp;trickier;&nbsp;it&nbsp;works&nbsp;by&nbsp;considering&nbsp;the&nbsp;set<br>&nbsp;*&nbsp;symmetric&nbsp;difference&nbsp;between&nbsp;a&nbsp;maximum&nbsp;matching&nbsp;and&nbsp;any&nbsp;other&nbsp;matching,&nbsp;then<br>&nbsp;*&nbsp;looking&nbsp;at&nbsp;the&nbsp;connected&nbsp;components&nbsp;of&nbsp;this&nbsp;graph;&nbsp;one&nbsp;can&nbsp;be&nbsp;shown&nbsp;to&nbsp;be<br>&nbsp;*&nbsp;the&nbsp;necessary&nbsp;alternating&nbsp;path.<br>&nbsp;*<br>&nbsp;*&nbsp;A&nbsp;collection&nbsp;of&nbsp;alternating&nbsp;paths&nbsp;can&nbsp;be&nbsp;formed&nbsp;together&nbsp;to&nbsp;create&nbsp;an<br>&nbsp;*&nbsp;&quot;alternating&nbsp;tree.&quot;&nbsp;&nbsp;An&nbsp;alternating&nbsp;tree&nbsp;is&nbsp;a&nbsp;tree&nbsp;defined&nbsp;with&nbsp;respect&nbsp;to<br>&nbsp;*&nbsp;a&nbsp;matching&nbsp;(G,&nbsp;M)&nbsp;as&nbsp;follows:<br>&nbsp;*<br>&nbsp;*&nbsp;&nbsp;1.&nbsp;The&nbsp;nodes&nbsp;are&nbsp;partitioned&nbsp;into&nbsp;two&nbsp;disjoint&nbsp;groups&nbsp;-&nbsp;&quot;outer&nbsp;vertices&quot;<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;&quot;inner&nbsp;vertices.&quot;<br>&nbsp;*&nbsp;&nbsp;2.&nbsp;Each&nbsp;inner&nbsp;vertex&nbsp;has&nbsp;degree&nbsp;two,&nbsp;and&nbsp;exactly&nbsp;one&nbsp;of&nbsp;its&nbsp;incident&nbsp;edges<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;in&nbsp;M.<br>&nbsp;*&nbsp;&nbsp;3.&nbsp;Each&nbsp;edge&nbsp;connects&nbsp;exactly&nbsp;one&nbsp;inner&nbsp;node&nbsp;and&nbsp;exactly&nbsp;one&nbsp;outer&nbsp;node.<br>&nbsp;*&nbsp;&nbsp;4.&nbsp;There&nbsp;is&nbsp;a&nbsp;unique&nbsp;outer&nbsp;node&nbsp;that&nbsp;is&nbsp;the&nbsp;root&nbsp;of&nbsp;the&nbsp;tree.<br>&nbsp;*&nbsp;&nbsp;5.&nbsp;Every&nbsp;path&nbsp;from&nbsp;a&nbsp;vertex&nbsp;to&nbsp;the&nbsp;root&nbsp;is&nbsp;an&nbsp;alternating&nbsp;path.<br>&nbsp;*&nbsp;&nbsp;6.&nbsp;Every&nbsp;path&nbsp;from&nbsp;an&nbsp;outer&nbsp;vertex&nbsp;to&nbsp;the&nbsp;root&nbsp;begins&nbsp;with&nbsp;an&nbsp;edge&nbsp;in&nbsp;M.<br>&nbsp;*<br>&nbsp;*&nbsp;This&nbsp;is&nbsp;a&nbsp;lot&nbsp;of&nbsp;structure&nbsp;to&nbsp;take&nbsp;in&nbsp;at&nbsp;once,&nbsp;so&nbsp;a&nbsp;more&nbsp;informal<br>&nbsp;*&nbsp;presentation&nbsp;is&nbsp;probably&nbsp;in&nbsp;order.&nbsp;&nbsp;You&nbsp;can&nbsp;think&nbsp;of&nbsp;an&nbsp;alternating&nbsp;tree&nbsp;as<br>&nbsp;*&nbsp;a&nbsp;tree&nbsp;formed&nbsp;as&nbsp;the&nbsp;concatenation&nbsp;of&nbsp;several&nbsp;&quot;gadgets&quot;&nbsp;formed&nbsp;of&nbsp;a&nbsp;solid<br>&nbsp;*&nbsp;edge&nbsp;(an&nbsp;edge&nbsp;in&nbsp;M)&nbsp;joined&nbsp;to&nbsp;a&nbsp;dashed&nbsp;edge&nbsp;(an&nbsp;edge&nbsp;not&nbsp;in&nbsp;M).&nbsp;&nbsp;The<br>&nbsp;*&nbsp;alternating&nbsp;tree&nbsp;is&nbsp;then&nbsp;a&nbsp;collection&nbsp;of&nbsp;paths&nbsp;formed&nbsp;from&nbsp;these&nbsp;gadgets<br>&nbsp;*&nbsp;concatenated&nbsp;together&nbsp;in&nbsp;such&nbsp;a&nbsp;way&nbsp;that&nbsp;the&nbsp;endpoint&nbsp;of&nbsp;each&nbsp;gadget&nbsp;is<br>&nbsp;*&nbsp;either&nbsp;a&nbsp;designated&nbsp;root&nbsp;node&nbsp;or&nbsp;the&nbsp;start&nbsp;point&nbsp;of&nbsp;some&nbsp;other&nbsp;gadget.&nbsp;&nbsp;The<br>&nbsp;*&nbsp;&quot;outer&nbsp;vertices&quot;&nbsp;from&nbsp;(1)&nbsp;are&nbsp;then&nbsp;the&nbsp;start&nbsp;nodes&nbsp;of&nbsp;the&nbsp;gadgets,&nbsp;while&nbsp;the<br>&nbsp;*&nbsp;&quot;inner&nbsp;vertices&quot;&nbsp;from&nbsp;(1)&nbsp;are&nbsp;the&nbsp;inner&nbsp;nodes.&nbsp;&nbsp;This&nbsp;automatically<br>&nbsp;*&nbsp;guarantees&nbsp;(2)&nbsp;and&nbsp;(3).&nbsp;&nbsp;The&nbsp;special&nbsp;root&nbsp;node&nbsp;is&nbsp;the&nbsp;unique&nbsp;outer&nbsp;node<br>&nbsp;*&nbsp;mentioned&nbsp;in&nbsp;(4),&nbsp;and&nbsp;the&nbsp;construction&nbsp;easily&nbsp;guarantees&nbsp;(5)&nbsp;and&nbsp;(6).<br>&nbsp;*<br>&nbsp;*&nbsp;The&nbsp;reason&nbsp;that&nbsp;these&nbsp;&quot;alternating&nbsp;trees&quot;&nbsp;are&nbsp;so&nbsp;useful&nbsp;is&nbsp;that&nbsp;they&nbsp;give&nbsp;a<br>&nbsp;*&nbsp;great&nbsp;way&nbsp;to&nbsp;locate&nbsp;alternating&nbsp;paths&nbsp;between&nbsp;exposed&nbsp;vertices.&nbsp;&nbsp;Suppose<br>&nbsp;*&nbsp;that&nbsp;we&nbsp;root&nbsp;an&nbsp;alternating&nbsp;tree&nbsp;at&nbsp;an&nbsp;exposed&nbsp;vertex&nbsp;and&nbsp;then&nbsp;find&nbsp;an<br>&nbsp;*&nbsp;edge&nbsp;from&nbsp;an&nbsp;outer&nbsp;node&nbsp;to&nbsp;an&nbsp;exposed&nbsp;vertex.&nbsp;&nbsp;This&nbsp;means&nbsp;that&nbsp;we&nbsp;then&nbsp;have<br>&nbsp;*&nbsp;an&nbsp;alternating&nbsp;path&nbsp;from&nbsp;that&nbsp;exposed&nbsp;vertex&nbsp;to&nbsp;the&nbsp;root&nbsp;of&nbsp;the&nbsp;tree,&nbsp;formed<br>&nbsp;*&nbsp;by&nbsp;taking&nbsp;the&nbsp;edge&nbsp;from&nbsp;the&nbsp;exposed&nbsp;vertex&nbsp;to&nbsp;the&nbsp;outer&nbsp;node&nbsp;and&nbsp;the&nbsp;path&nbsp;<br>&nbsp;*&nbsp;from&nbsp;the&nbsp;outer&nbsp;node&nbsp;to&nbsp;the&nbsp;root&nbsp;of&nbsp;the&nbsp;tree&nbsp;(which&nbsp;is&nbsp;alternating&nbsp;and&nbsp;starts<br>&nbsp;*&nbsp;with&nbsp;a&nbsp;matched&nbsp;edge).&nbsp;&nbsp;The&nbsp;algorithm&nbsp;thus&nbsp;works&nbsp;by&nbsp;growing&nbsp;this&nbsp;alternating<br>&nbsp;*&nbsp;tree&nbsp;from&nbsp;an&nbsp;arbitrary&nbsp;exposed&nbsp;node&nbsp;outward&nbsp;until&nbsp;either&nbsp;every&nbsp;node&nbsp;is&nbsp;part<br>&nbsp;*&nbsp;of&nbsp;the&nbsp;tree&nbsp;(in&nbsp;which&nbsp;case&nbsp;no&nbsp;alternating&nbsp;path&nbsp;exists&nbsp;and&nbsp;we&nbsp;have&nbsp;a&nbsp;maximum<br>&nbsp;*&nbsp;matching),&nbsp;or&nbsp;until&nbsp;an&nbsp;alternating&nbsp;path&nbsp;is&nbsp;found.<br>&nbsp;*<br>&nbsp;*&nbsp;There&nbsp;is&nbsp;one&nbsp;last&nbsp;detail&nbsp;to&nbsp;worry&nbsp;about,&nbsp;and&nbsp;that's&nbsp;what&nbsp;happens&nbsp;if&nbsp;there&nbsp;is<br>&nbsp;*&nbsp;an&nbsp;unmatched&nbsp;edge&nbsp;in&nbsp;the&nbsp;graph&nbsp;that&nbsp;links&nbsp;together&nbsp;two&nbsp;from&nbsp;two&nbsp;outer&nbsp;nodes<br>&nbsp;*&nbsp;of&nbsp;the&nbsp;tree.&nbsp;&nbsp;If&nbsp;this&nbsp;happens,&nbsp;this&nbsp;means&nbsp;that&nbsp;there&nbsp;is&nbsp;an&nbsp;odd&nbsp;cycle&nbsp;in&nbsp;the<br>&nbsp;*&nbsp;graph,&nbsp;and&nbsp;it&nbsp;might&nbsp;be&nbsp;possible&nbsp;for&nbsp;an&nbsp;alternating&nbsp;path&nbsp;to&nbsp;exist&nbsp;in&nbsp;the<br>&nbsp;*&nbsp;graph&nbsp;that&nbsp;wouldn't&nbsp;be&nbsp;noticed&nbsp;by&nbsp;the&nbsp;tree&nbsp;(you&nbsp;should&nbsp;draw&nbsp;out&nbsp;a&nbsp;picture<br>&nbsp;*&nbsp;here&nbsp;to&nbsp;convince&nbsp;yourself&nbsp;that&nbsp;this&nbsp;is&nbsp;true).&nbsp;&nbsp;When&nbsp;this&nbsp;happens,&nbsp;the<br>&nbsp;*&nbsp;algorithm&nbsp;&quot;contracts&quot;&nbsp;the&nbsp;odd&nbsp;cycle&nbsp;down&nbsp;to&nbsp;a&nbsp;single&nbsp;node,&nbsp;then&nbsp;recursively<br>&nbsp;*&nbsp;searches&nbsp;this&nbsp;new&nbsp;graph&nbsp;for&nbsp;an&nbsp;alternating&nbsp;path.&nbsp;&nbsp;If&nbsp;one&nbsp;exists&nbsp;and&nbsp;doesn't<br>&nbsp;*&nbsp;pass&nbsp;through&nbsp;this&nbsp;new&nbsp;pseudonode,&nbsp;then&nbsp;it's&nbsp;an&nbsp;alternating&nbsp;path&nbsp;in&nbsp;the&nbsp;old<br>&nbsp;*&nbsp;graph.&nbsp;&nbsp;If&nbsp;it&nbsp;does&nbsp;pass&nbsp;through&nbsp;the&nbsp;new&nbsp;pseudonode,&nbsp;then&nbsp;the&nbsp;path&nbsp;can&nbsp;be<br>&nbsp;*&nbsp;expanded&nbsp;back&nbsp;into&nbsp;a&nbsp;path&nbsp;in&nbsp;the&nbsp;original&nbsp;graph&nbsp;by&nbsp;modifying&nbsp;the&nbsp;matching<br>&nbsp;*&nbsp;so&nbsp;that&nbsp;the&nbsp;path&nbsp;through&nbsp;the&nbsp;cycle&nbsp;back&nbsp;to&nbsp;the&nbsp;root&nbsp;is&nbsp;alternating&nbsp;(this<br>&nbsp;*&nbsp;doesn't&nbsp;affect&nbsp;the&nbsp;cardinality&nbsp;of&nbsp;the&nbsp;matching),&nbsp;then&nbsp;returning&nbsp;the&nbsp;proper<br>&nbsp;*&nbsp;alternating&nbsp;path.<br>&nbsp;*<br>&nbsp;*&nbsp;The&nbsp;algorithm&nbsp;can&nbsp;make&nbsp;at&nbsp;most&nbsp;O(n)&nbsp;iterations&nbsp;of&nbsp;finding&nbsp;alternating&nbsp;paths,<br>&nbsp;*&nbsp;since&nbsp;a&nbsp;maximum&nbsp;matching&nbsp;has&nbsp;cardinality&nbsp;at&nbsp;most&nbsp;n/2.&nbsp;&nbsp;During&nbsp;each&nbsp;iteration<br>&nbsp;*&nbsp;of&nbsp;the&nbsp;tree-growing&nbsp;step,&nbsp;we&nbsp;need&nbsp;to&nbsp;consider&nbsp;each&nbsp;edge&nbsp;at&nbsp;most&nbsp;once,&nbsp;since<br>&nbsp;*&nbsp;it&nbsp;either&nbsp;goes&nbsp;in&nbsp;the&nbsp;tree,&nbsp;finds&nbsp;an&nbsp;augmenting&nbsp;path,&nbsp;or&nbsp;creates&nbsp;a&nbsp;cycle.<br>&nbsp;*&nbsp;Whenever&nbsp;a&nbsp;cycle&nbsp;is&nbsp;found,&nbsp;we&nbsp;can&nbsp;create&nbsp;the&nbsp;graph&nbsp;formed&nbsp;by&nbsp;contracting<br>&nbsp;*&nbsp;that&nbsp;cycle&nbsp;in&nbsp;O(m)&nbsp;by&nbsp;scanning&nbsp;over&nbsp;the&nbsp;edges.&nbsp;&nbsp;Finally,&nbsp;we&nbsp;can&nbsp;have&nbsp;at&nbsp;most<br>&nbsp;*&nbsp;O(n)&nbsp;contractions,&nbsp;because&nbsp;each&nbsp;contraction&nbsp;removes&nbsp;at&nbsp;least&nbsp;one&nbsp;node.&nbsp;&nbsp;This<br>&nbsp;*&nbsp;gives&nbsp;the&nbsp;algorithm&nbsp;a&nbsp;runtime&nbsp;of&nbsp;O(n^2&nbsp;m).<br>&nbsp;*/</span><br><span style="color: blue">import</span>&nbsp;java.util.*;&nbsp;<span style="color: green">//&nbsp;For&nbsp;ArrayDeque,&nbsp;HashMap,&nbsp;HashSet,&nbsp;LinkedList<br></span><br><span style="color: blue">public</span>&nbsp;<span style="color: blue">final</span>&nbsp;<span style="color: blue">class</span>&nbsp;EdmondsMatching&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: teal">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Given&nbsp;an&nbsp;undirected&nbsp;graph,&nbsp;returns&nbsp;a&nbsp;graph&nbsp;containing&nbsp;the&nbsp;edges&nbsp;of&nbsp;a<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;maximum&nbsp;matching&nbsp;in&nbsp;that&nbsp;graph.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;g&nbsp;The&nbsp;graph&nbsp;in&nbsp;which&nbsp;a&nbsp;maximum&nbsp;matching&nbsp;should&nbsp;be&nbsp;found.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;A&nbsp;graph&nbsp;containing&nbsp;a&nbsp;maximum&nbsp;matching&nbsp;in&nbsp;that&nbsp;graph.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">public</span>&nbsp;<span style="color: blue">static</span>&nbsp;&lt;T&gt;&nbsp;UndirectedGraph&lt;T&gt;&nbsp;maximumMatching(UndirectedGraph&lt;T&gt;&nbsp;g)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Edge&nbsp;case&nbsp;-&nbsp;if&nbsp;the&nbsp;graph&nbsp;is&nbsp;empty,&nbsp;just&nbsp;hand&nbsp;back&nbsp;an&nbsp;empty&nbsp;graph&nbsp;as<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;the&nbsp;matching.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">if</span>&nbsp;(g.isEmpty())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">return</span>&nbsp;<span style="color: blue">new</span>&nbsp;UndirectedGraph&lt;T&gt;();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Construct&nbsp;a&nbsp;new&nbsp;graph&nbsp;to&nbsp;hold&nbsp;the&nbsp;matching.&nbsp;&nbsp;Fill&nbsp;it&nbsp;with&nbsp;the&nbsp;nodes<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;from&nbsp;the&nbsp;original&nbsp;graph,&nbsp;but&nbsp;not&nbsp;the&nbsp;edges.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UndirectedGraph&lt;T&gt;&nbsp;result&nbsp;=&nbsp;<span style="color: blue">new</span>&nbsp;UndirectedGraph&lt;T&gt;();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">for</span>&nbsp;(T&nbsp;node:&nbsp;g)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.addNode(node);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Now,&nbsp;continuously&nbsp;iterate,&nbsp;looking&nbsp;for&nbsp;alternating&nbsp;paths&nbsp;between<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;exposed&nbsp;vertices&nbsp;until&nbsp;none&nbsp;can&nbsp;be&nbsp;found.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">while</span>&nbsp;(<span style="color: blue">true</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Look&nbsp;up&nbsp;a&nbsp;path.&nbsp;&nbsp;If&nbsp;none&nbsp;exists,&nbsp;this&nbsp;function&nbsp;returns&nbsp;null&nbsp;as<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;a&nbsp;sentinel,&nbsp;which&nbsp;we&nbsp;can&nbsp;use&nbsp;as&nbsp;a&nbsp;cue&nbsp;that&nbsp;we're&nbsp;done.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;T&gt;&nbsp;path&nbsp;=&nbsp;findAlternatingPath(g,&nbsp;result);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">if</span>&nbsp;(path&nbsp;==&nbsp;<span style="color: blue">null</span>)&nbsp;<span style="color: blue">return</span>&nbsp;result;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;If&nbsp;not,&nbsp;update&nbsp;the&nbsp;graph&nbsp;using&nbsp;this&nbsp;alternating&nbsp;path.&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updateMatching(path,&nbsp;result);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: teal">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Updates&nbsp;a&nbsp;matching&nbsp;by&nbsp;increasing&nbsp;the&nbsp;cardinality&nbsp;of&nbsp;the&nbsp;matching&nbsp;by<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;flipping&nbsp;the&nbsp;status&nbsp;of&nbsp;the&nbsp;edges&nbsp;in&nbsp;the&nbsp;specified&nbsp;alternating&nbsp;path.&nbsp;&nbsp;It<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;is&nbsp;assumed&nbsp;that&nbsp;the&nbsp;alternating&nbsp;path&nbsp;is&nbsp;between&nbsp;exposed&nbsp;vertices,&nbsp;which<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;means&nbsp;that&nbsp;the&nbsp;edges&nbsp;[0,&nbsp;1],&nbsp;[2,&nbsp;3],&nbsp;...,&nbsp;[n-2,&nbsp;n-1]&nbsp;are&nbsp;assumed&nbsp;not&nbsp;to<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;be&nbsp;in&nbsp;the&nbsp;matching.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;path&nbsp;The&nbsp;alternating&nbsp;path&nbsp;linking&nbsp;the&nbsp;exposed&nbsp;endpoints.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;m&nbsp;The&nbsp;matching&nbsp;to&nbsp;update,&nbsp;which&nbsp;is&nbsp;an&nbsp;in/out&nbsp;parameter.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">private</span>&nbsp;<span style="color: blue">static</span>&nbsp;&lt;T&gt;&nbsp;<span style="color: blue">void</span>&nbsp;updateMatching(List&lt;T&gt;&nbsp;path,&nbsp;UndirectedGraph&lt;T&gt;&nbsp;m)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Scan&nbsp;across&nbsp;the&nbsp;edges&nbsp;in&nbsp;the&nbsp;path,&nbsp;flipping&nbsp;whether&nbsp;or&nbsp;not&nbsp;they're<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;in&nbsp;the&nbsp;matching.&nbsp;&nbsp;This&nbsp;iteration&nbsp;counts&nbsp;up&nbsp;to&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;list<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;minus&nbsp;one&nbsp;because&nbsp;each&nbsp;iteration&nbsp;looks&nbsp;at&nbsp;the&nbsp;edge&nbsp;(i,&nbsp;i&nbsp;+&nbsp;1).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">for</span>&nbsp;(<span style="color: blue">int</span>&nbsp;i&nbsp;=&nbsp;<span style="color: orange">0</span>;&nbsp;i&nbsp;&lt;&nbsp;path.size()&nbsp;-&nbsp;<span style="color: orange">1</span>;&nbsp;++i)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Check&nbsp;whether&nbsp;the&nbsp;edge&nbsp;exists&nbsp;and&nbsp;react&nbsp;appropriately.&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">if</span>&nbsp;(m.edgeExists(path.get(i),&nbsp;path.get(i&nbsp;+&nbsp;<span style="color: orange">1</span>)))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.removeEdge(path.get(i),&nbsp;path.get(i&nbsp;+&nbsp;<span style="color: orange">1</span>));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">else</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.addEdge(path.get(i),&nbsp;path.get(i&nbsp;+&nbsp;<span style="color: orange">1</span>));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;A&nbsp;key&nbsp;step&nbsp;of&nbsp;the&nbsp;algorithm&nbsp;works&nbsp;by&nbsp;building&nbsp;up&nbsp;a&nbsp;collection&nbsp;of<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;forests&nbsp;of&nbsp;alternating&nbsp;trees.&nbsp;&nbsp;We&nbsp;will&nbsp;need&nbsp;to&nbsp;be&nbsp;able&nbsp;to&nbsp;answer<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;the&nbsp;following&nbsp;queries&nbsp;about&nbsp;the&nbsp;tree&nbsp;structure:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;1.&nbsp;For&nbsp;each&nbsp;node,&nbsp;what&nbsp;tree&nbsp;is&nbsp;it&nbsp;a&nbsp;part&nbsp;of?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;2.&nbsp;For&nbsp;each&nbsp;node,&nbsp;what&nbsp;is&nbsp;its&nbsp;parent&nbsp;node&nbsp;in&nbsp;the&nbsp;tree?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;3.&nbsp;For&nbsp;each&nbsp;node,&nbsp;is&nbsp;it&nbsp;an&nbsp;inner&nbsp;or&nbsp;outer&nbsp;node&nbsp;in&nbsp;its&nbsp;tree?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;We&nbsp;will&nbsp;represent&nbsp;all&nbsp;of&nbsp;this&nbsp;information&nbsp;by&nbsp;a&nbsp;utility&nbsp;struct&nbsp;that<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;stores&nbsp;this&nbsp;information.&nbsp;&nbsp;For&nbsp;simplicity,&nbsp;each&nbsp;node&nbsp;will&nbsp;be<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;identified&nbsp;with&nbsp;its&nbsp;root.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">private</span>&nbsp;<span style="color: blue">static</span>&nbsp;<span style="color: blue">final</span>&nbsp;<span style="color: blue">class</span>&nbsp;NodeInformation&lt;T&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">public</span>&nbsp;<span style="color: blue">final</span>&nbsp;T&nbsp;parent;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">public</span>&nbsp;<span style="color: blue">final</span>&nbsp;T&nbsp;treeRoot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">public</span>&nbsp;<span style="color: blue">final</span>&nbsp;<span style="color: blue">boolean</span>&nbsp;isOuter;&nbsp;<span style="color: green">//&nbsp;True&nbsp;for&nbsp;outer&nbsp;node,&nbsp;false&nbsp;for&nbsp;inner.<br></span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: teal">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Constructs&nbsp;a&nbsp;new&nbsp;NodeInformation&nbsp;wrapping&nbsp;the&nbsp;indicated&nbsp;data.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;parent&nbsp;The&nbsp;parent&nbsp;of&nbsp;the&nbsp;given&nbsp;node.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;treeRoot&nbsp;The&nbsp;root&nbsp;of&nbsp;the&nbsp;given&nbsp;node.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;isOuter&nbsp;Whether&nbsp;the&nbsp;given&nbsp;node&nbsp;is&nbsp;an&nbsp;outer&nbsp;node.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">public</span>&nbsp;NodeInformation(T&nbsp;parent,&nbsp;T&nbsp;treeRoot,&nbsp;<span style="color: blue">boolean</span>&nbsp;isOuter)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">this</span>.parent&nbsp;=&nbsp;parent;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">this</span>.treeRoot&nbsp;=&nbsp;treeRoot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">this</span>.isOuter&nbsp;=&nbsp;isOuter;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;A&nbsp;utility&nbsp;struct&nbsp;representing&nbsp;an&nbsp;edge&nbsp;in&nbsp;the&nbsp;graph.&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">private</span>&nbsp;<span style="color: blue">static</span>&nbsp;<span style="color: blue">final</span>&nbsp;<span style="color: blue">class</span>&nbsp;Edge&lt;T&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">public</span>&nbsp;<span style="color: blue">final</span>&nbsp;T&nbsp;start;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">public</span>&nbsp;<span style="color: blue">final</span>&nbsp;T&nbsp;end;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: teal">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Constructs&nbsp;a&nbsp;new&nbsp;edge&nbsp;between&nbsp;the&nbsp;two&nbsp;indicated&nbsp;endpoints.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;start&nbsp;The&nbsp;edge's&nbsp;starting&nbsp;point.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;end&nbsp;The&nbsp;edge's&nbsp;endpoint.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">public</span>&nbsp;Edge(T&nbsp;start,&nbsp;T&nbsp;end)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">this</span>.start&nbsp;=&nbsp;start;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">this</span>.end&nbsp;=&nbsp;end;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;One&nbsp;final&nbsp;piece&nbsp;of&nbsp;information&nbsp;that's&nbsp;necessary&nbsp;to&nbsp;get&nbsp;the&nbsp;algorithm<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;working&nbsp;is&nbsp;the&nbsp;ability&nbsp;to&nbsp;locate&nbsp;and&nbsp;navigate&nbsp;odd&nbsp;alternating&nbsp;cycles&nbsp;in<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;the&nbsp;alternating&nbsp;forest.&nbsp;&nbsp;Once&nbsp;we've&nbsp;found&nbsp;such&nbsp;a&nbsp;cycle,&nbsp;we&nbsp;need&nbsp;to<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;contract&nbsp;it&nbsp;down&nbsp;to&nbsp;a&nbsp;single&nbsp;node,&nbsp;find&nbsp;an&nbsp;alternating&nbsp;path&nbsp;in&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;contracted&nbsp;graph,&nbsp;then&nbsp;expand&nbsp;the&nbsp;path&nbsp;back&nbsp;into&nbsp;an&nbsp;alternating&nbsp;path&nbsp;in<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;the&nbsp;original&nbsp;graph.&nbsp;&nbsp;To&nbsp;do&nbsp;this,&nbsp;we&nbsp;need&nbsp;to&nbsp;be&nbsp;able&nbsp;to&nbsp;answer&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;following&nbsp;questions&nbsp;efficiently:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;1.&nbsp;What&nbsp;nodes&nbsp;are&nbsp;in&nbsp;the&nbsp;cycle&nbsp;(blossom)?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;2.&nbsp;Starting&nbsp;at&nbsp;the&nbsp;root&nbsp;of&nbsp;the&nbsp;blossom,&nbsp;what&nbsp;order&nbsp;do&nbsp;the&nbsp;edges&nbsp;go&nbsp;in?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;3.&nbsp;What&nbsp;node&nbsp;is&nbsp;used&nbsp;to&nbsp;represent&nbsp;the&nbsp;cycle&nbsp;in&nbsp;the&nbsp;contracted&nbsp;graph?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;This&nbsp;information&nbsp;is&nbsp;encoded&nbsp;in&nbsp;this&nbsp;utility&nbsp;struct.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">private</span>&nbsp;<span style="color: blue">static</span>&nbsp;<span style="color: blue">final</span>&nbsp;<span style="color: blue">class</span>&nbsp;Blossom&lt;T&gt;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">public</span>&nbsp;<span style="color: blue">final</span>&nbsp;T&nbsp;root;&nbsp;<span style="color: green">//&nbsp;The&nbsp;root&nbsp;of&nbsp;the&nbsp;blossom;&nbsp;also&nbsp;the&nbsp;representative<br></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">public</span>&nbsp;<span style="color: blue">final</span>&nbsp;List&lt;T&gt;&nbsp;cycle;&nbsp;<span style="color: green">//&nbsp;The&nbsp;nodes,&nbsp;listed&nbsp;in&nbsp;order&nbsp;around&nbsp;the&nbsp;cycle<br></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">public</span>&nbsp;<span style="color: blue">final</span>&nbsp;Set&lt;T&gt;&nbsp;nodes;&nbsp;<span style="color: green">//&nbsp;The&nbsp;nodes,&nbsp;stored&nbsp;in&nbsp;a&nbsp;set&nbsp;for&nbsp;efficient&nbsp;lookup<br></span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: teal">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Given&nbsp;information&nbsp;about&nbsp;the&nbsp;blossom,&nbsp;constructs&nbsp;a&nbsp;new&nbsp;Blossom<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;holding&nbsp;this&nbsp;information.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;root&nbsp;The&nbsp;root&nbsp;node&nbsp;of&nbsp;the&nbsp;blossom.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;cycle&nbsp;The&nbsp;nodes&nbsp;of&nbsp;the&nbsp;cycle&nbsp;listed&nbsp;in&nbsp;the&nbsp;order&nbsp;in&nbsp;which<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;they&nbsp;appear&nbsp;in&nbsp;the&nbsp;blossom.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;nodes&nbsp;The&nbsp;nodes&nbsp;in&nbsp;the&nbsp;cycle,&nbsp;stored&nbsp;as&nbsp;a&nbsp;set.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">public</span>&nbsp;Blossom(T&nbsp;root,&nbsp;List&lt;T&gt;&nbsp;cycle,&nbsp;Set&lt;T&gt;&nbsp;nodes)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">this</span>.root&nbsp;=&nbsp;root;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">this</span>.cycle&nbsp;=&nbsp;cycle;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">this</span>.nodes&nbsp;=&nbsp;nodes;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: teal">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Given&nbsp;a&nbsp;graph&nbsp;and&nbsp;a&nbsp;matching&nbsp;in&nbsp;that&nbsp;graph,&nbsp;returns&nbsp;an&nbsp;augmenting&nbsp;path<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;in&nbsp;the&nbsp;graph&nbsp;if&nbsp;one&nbsp;exists.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;g&nbsp;The&nbsp;graph&nbsp;in&nbsp;which&nbsp;to&nbsp;search&nbsp;for&nbsp;the&nbsp;path.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;m&nbsp;A&nbsp;matching&nbsp;in&nbsp;that&nbsp;graph.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;An&nbsp;alternating&nbsp;path&nbsp;in&nbsp;g,&nbsp;or&nbsp;null&nbsp;if&nbsp;none&nbsp;exists.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">private</span>&nbsp;<span style="color: blue">static</span>&nbsp;&lt;T&gt;&nbsp;List&lt;T&gt;&nbsp;findAlternatingPath(UndirectedGraph&lt;T&gt;&nbsp;g,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UndirectedGraph&lt;T&gt;&nbsp;m)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;We&nbsp;need&nbsp;to&nbsp;maintain&nbsp;as&nbsp;state&nbsp;all&nbsp;of&nbsp;the&nbsp;forests&nbsp;that&nbsp;are&nbsp;currently<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;being&nbsp;considered.&nbsp;&nbsp;To&nbsp;do&nbsp;this,&nbsp;we'll&nbsp;create&nbsp;a&nbsp;map&nbsp;associating&nbsp;each<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;node&nbsp;with&nbsp;its&nbsp;information.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map&lt;T,&nbsp;NodeInformation&lt;T&gt;&gt;&nbsp;forest&nbsp;=&nbsp;<span style="color: blue">new</span>&nbsp;HashMap&lt;T,&nbsp;NodeInformation&lt;T&gt;&gt;();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;We&nbsp;also&nbsp;will&nbsp;maintain&nbsp;a&nbsp;worklist&nbsp;of&nbsp;edges&nbsp;that&nbsp;need&nbsp;to&nbsp;be<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;considered.&nbsp;&nbsp;These&nbsp;will&nbsp;be&nbsp;explored&nbsp;in&nbsp;a&nbsp;breadth-first&nbsp;fashion.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Whenever&nbsp;we&nbsp;add&nbsp;a&nbsp;new&nbsp;node&nbsp;to&nbsp;the&nbsp;forest,&nbsp;we'll&nbsp;add&nbsp;all&nbsp;its<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;outgoing&nbsp;edges&nbsp;to&nbsp;this&nbsp;queue.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queue&lt;Edge&lt;T&gt;&gt;&nbsp;worklist&nbsp;=&nbsp;<span style="color: blue">new</span>&nbsp;LinkedList&lt;Edge&lt;T&gt;&gt;();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Begin&nbsp;by&nbsp;adding&nbsp;all&nbsp;of&nbsp;the&nbsp;exposed&nbsp;vertices&nbsp;to&nbsp;the&nbsp;forest&nbsp;as&nbsp;their<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;own&nbsp;singleton&nbsp;trees.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">for</span>&nbsp;(T&nbsp;node:&nbsp;g)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Check&nbsp;if&nbsp;the&nbsp;node&nbsp;is&nbsp;a&nbsp;singleton&nbsp;by&nbsp;seeing&nbsp;if&nbsp;it&nbsp;has&nbsp;no&nbsp;edges<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;leaving&nbsp;it&nbsp;in&nbsp;the&nbsp;matching.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">if</span>&nbsp;(!m.edgesFrom(node).isEmpty())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">continue</span>;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;This&nbsp;node&nbsp;is&nbsp;an&nbsp;outer&nbsp;node&nbsp;that&nbsp;has&nbsp;no&nbsp;parent&nbsp;and&nbsp;belongs&nbsp;in<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;its&nbsp;own&nbsp;tree.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forest.put(node,&nbsp;<span style="color: blue">new</span>&nbsp;NodeInformation&lt;T&gt;(<span style="color: blue">null</span>,&nbsp;node,&nbsp;<span style="color: blue">true</span>));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Add&nbsp;to&nbsp;the&nbsp;worklist&nbsp;all&nbsp;edges&nbsp;leaving&nbsp;this&nbsp;node.&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">for</span>&nbsp;(T&nbsp;endpoint:&nbsp;g.edgesFrom(node))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;worklist.add(<span style="color: blue">new</span>&nbsp;Edge&lt;T&gt;(node,&nbsp;endpoint));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Now,&nbsp;we&nbsp;start&nbsp;growing&nbsp;all&nbsp;the&nbsp;trees&nbsp;outward&nbsp;by&nbsp;considering&nbsp;edges<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;leaving&nbsp;each&nbsp;tree.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">while</span>&nbsp;(!worklist.isEmpty())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Grab&nbsp;the&nbsp;next&nbsp;edge.&nbsp;&nbsp;We're&nbsp;only&nbsp;growing&nbsp;the&nbsp;tree&nbsp;along&nbsp;edges<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;that&nbsp;are&nbsp;not&nbsp;part&nbsp;of&nbsp;the&nbsp;matching&nbsp;(since&nbsp;we're&nbsp;looking&nbsp;to&nbsp;grow<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;trees&nbsp;with&nbsp;pairs&nbsp;of&nbsp;edges,&nbsp;a&nbsp;non-matched&nbsp;edge&nbsp;from&nbsp;an&nbsp;outer<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;node&nbsp;to&nbsp;an&nbsp;inner&nbsp;node,&nbsp;followed&nbsp;by&nbsp;a&nbsp;matched&nbsp;edge&nbsp;to&nbsp;some&nbsp;next<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;node.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Edge&lt;T&gt;&nbsp;curr&nbsp;=&nbsp;worklist.remove();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">if</span>&nbsp;(m.edgeExists(curr.start,&nbsp;curr.end))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">continue</span>;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Look&nbsp;up&nbsp;the&nbsp;information&nbsp;associated&nbsp;with&nbsp;the&nbsp;endpoints.&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeInformation&lt;T&gt;&nbsp;startInfo&nbsp;=&nbsp;forest.get(curr.start);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeInformation&lt;T&gt;&nbsp;endInfo&nbsp;=&nbsp;forest.get(curr.end);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;We&nbsp;have&nbsp;several&nbsp;cases&nbsp;to&nbsp;consider.&nbsp;&nbsp;First,&nbsp;if&nbsp;the&nbsp;endpoint&nbsp;of<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;this&nbsp;edge&nbsp;is&nbsp;in&nbsp;some&nbsp;tree,&nbsp;there&nbsp;are&nbsp;two&nbsp;options:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;1.&nbsp;If&nbsp;both&nbsp;endpoints&nbsp;are&nbsp;outer&nbsp;nodes&nbsp;in&nbsp;the&nbsp;same&nbsp;tree,&nbsp;we&nbsp;have<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;found&nbsp;an&nbsp;odd-length&nbsp;cycle&nbsp;(blossom).&nbsp;&nbsp;We&nbsp;then&nbsp;contract&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;edges&nbsp;in&nbsp;the&nbsp;cycle,&nbsp;repeat&nbsp;the&nbsp;search&nbsp;in&nbsp;the&nbsp;contracted<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;graph,&nbsp;then&nbsp;expand&nbsp;the&nbsp;result.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;2.&nbsp;If&nbsp;both&nbsp;endpoints&nbsp;are&nbsp;outer&nbsp;nodes&nbsp;in&nbsp;different&nbsp;trees,&nbsp;then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;we've&nbsp;found&nbsp;an&nbsp;augmenting&nbsp;path&nbsp;from&nbsp;the&nbsp;root&nbsp;of&nbsp;one&nbsp;tree<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;down&nbsp;through&nbsp;the&nbsp;other.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;3.&nbsp;If&nbsp;one&nbsp;endpoint&nbsp;is&nbsp;an&nbsp;outer&nbsp;node&nbsp;and&nbsp;one&nbsp;is&nbsp;an&nbsp;inner&nbsp;node,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;we&nbsp;don't&nbsp;need&nbsp;to&nbsp;do&nbsp;anything.&nbsp;&nbsp;The&nbsp;path&nbsp;that&nbsp;we&nbsp;would&nbsp;end<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;up&nbsp;taking&nbsp;from&nbsp;the&nbsp;root&nbsp;of&nbsp;the&nbsp;first&nbsp;tree&nbsp;through&nbsp;this&nbsp;edge<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;would&nbsp;not&nbsp;end&nbsp;up&nbsp;at&nbsp;the&nbsp;root&nbsp;of&nbsp;the&nbsp;other&nbsp;tree,&nbsp;since&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;only&nbsp;way&nbsp;we&nbsp;could&nbsp;do&nbsp;this&nbsp;while&nbsp;alternating&nbsp;would&nbsp;direct&nbsp;us<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;away&nbsp;from&nbsp;the&nbsp;root.&nbsp;&nbsp;We&nbsp;can&nbsp;just&nbsp;skip&nbsp;this&nbsp;edge.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">if</span>&nbsp;(endInfo&nbsp;!=&nbsp;<span style="color: blue">null</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Case&nbsp;1:&nbsp;Do&nbsp;the&nbsp;contraction.&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">if</span>&nbsp;(endInfo.isOuter&nbsp;&amp;&amp;&nbsp;startInfo.treeRoot&nbsp;==&nbsp;endInfo.treeRoot)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Get&nbsp;information&nbsp;about&nbsp;the&nbsp;blossom&nbsp;necessary&nbsp;to&nbsp;reduce<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;the&nbsp;graph.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Blossom&lt;T&gt;&nbsp;blossom&nbsp;=&nbsp;findBlossom(forest,&nbsp;curr);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Next,&nbsp;rebuild&nbsp;the&nbsp;graph&nbsp;using&nbsp;the&nbsp;indicated&nbsp;pseudonode,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;and&nbsp;recursively&nbsp;search&nbsp;it&nbsp;for&nbsp;an&nbsp;augmenting&nbsp;path.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;T&gt;&nbsp;path&nbsp;=&nbsp;findAlternatingPath(contractGraph(g,&nbsp;blossom),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contractGraph(m,&nbsp;blossom));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;If&nbsp;no&nbsp;augmenting&nbsp;path&nbsp;exists,&nbsp;then&nbsp;no&nbsp;augmenting&nbsp;path<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;exists&nbsp;in&nbsp;this&nbsp;graph&nbsp;either.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">if</span>&nbsp;(path&nbsp;==&nbsp;<span style="color: blue">null</span>)&nbsp;<span style="color: blue">return</span>&nbsp;path;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Otherwise,&nbsp;expand&nbsp;the&nbsp;path&nbsp;out&nbsp;into&nbsp;a&nbsp;path&nbsp;in&nbsp;this<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;graph,&nbsp;then&nbsp;return&nbsp;it.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">return</span>&nbsp;expandPath(path,&nbsp;g,&nbsp;forest,&nbsp;blossom);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Case&nbsp;2:&nbsp;Return&nbsp;the&nbsp;augmenting&nbsp;path&nbsp;from&nbsp;root&nbsp;to&nbsp;root.&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">else</span>&nbsp;<span style="color: blue">if</span>&nbsp;(endInfo.isOuter&nbsp;&amp;&amp;&nbsp;startInfo.treeRoot&nbsp;!=&nbsp;endInfo.treeRoot)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;The&nbsp;alternating&nbsp;path&nbsp;that&nbsp;we'll&nbsp;be&nbsp;building&nbsp;consists&nbsp;of<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;the&nbsp;path&nbsp;from&nbsp;the&nbsp;root&nbsp;of&nbsp;the&nbsp;first&nbsp;tree&nbsp;to&nbsp;the&nbsp;first<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;outer&nbsp;node,&nbsp;followed&nbsp;by&nbsp;the&nbsp;edge,&nbsp;followed&nbsp;by&nbsp;the&nbsp;path<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;from&nbsp;the&nbsp;second&nbsp;outer&nbsp;node&nbsp;to&nbsp;its&nbsp;root.&nbsp;&nbsp;Our&nbsp;path&nbsp;info<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;is&nbsp;stored&nbsp;in&nbsp;a&nbsp;fashion&nbsp;that&nbsp;makes&nbsp;it&nbsp;easy&nbsp;to&nbsp;walk&nbsp;up<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;to&nbsp;the&nbsp;root,&nbsp;and&nbsp;so&nbsp;we'll&nbsp;build&nbsp;up&nbsp;the&nbsp;path&nbsp;(which<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;we'll&nbsp;represent&nbsp;by&nbsp;a&nbsp;deque)&nbsp;by&nbsp;walking&nbsp;up&nbsp;to&nbsp;the&nbsp;tree<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;roots&nbsp;and&nbsp;creating&nbsp;the&nbsp;path&nbsp;as&nbsp;appropriate.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;T&gt;&nbsp;result&nbsp;=&nbsp;<span style="color: blue">new</span>&nbsp;ArrayList&lt;T&gt;();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Get&nbsp;the&nbsp;path&nbsp;from&nbsp;the&nbsp;first&nbsp;node&nbsp;to&nbsp;the&nbsp;root.&nbsp;&nbsp;Note&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;that&nbsp;this&nbsp;path&nbsp;is&nbsp;backwards,&nbsp;so&nbsp;we'll&nbsp;need&nbsp;to&nbsp;reverse<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;it&nbsp;afterwards.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">for</span>&nbsp;(T&nbsp;node&nbsp;=&nbsp;curr.start;&nbsp;node&nbsp;!=&nbsp;<span style="color: blue">null</span>;&nbsp;node&nbsp;=&nbsp;forest.get(node).parent)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.add(node);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Turn&nbsp;the&nbsp;path&nbsp;around.&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;reversePath(result);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Path&nbsp;from&nbsp;edge&nbsp;end&nbsp;to&nbsp;its&nbsp;root.&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">for</span>&nbsp;(T&nbsp;node&nbsp;=&nbsp;curr.end;&nbsp;node&nbsp;!=&nbsp;<span style="color: blue">null</span>;&nbsp;node&nbsp;=&nbsp;forest.get(node).parent)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.add(node);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">return</span>&nbsp;result;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Case&nbsp;3&nbsp;requires&nbsp;no&nbsp;processing.&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Otherwise,&nbsp;we&nbsp;have&nbsp;no&nbsp;info&nbsp;on&nbsp;this&nbsp;edge,&nbsp;which&nbsp;means&nbsp;that&nbsp;it<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;must&nbsp;correspond&nbsp;to&nbsp;a&nbsp;matched&nbsp;node&nbsp;(all&nbsp;exposed&nbsp;nodes&nbsp;are&nbsp;in&nbsp;a<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;forest).&nbsp;&nbsp;We'll&nbsp;thus&nbsp;add&nbsp;that&nbsp;node&nbsp;to&nbsp;the&nbsp;tree&nbsp;containing&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;start&nbsp;of&nbsp;the&nbsp;endpoint&nbsp;as&nbsp;an&nbsp;inner&nbsp;node,&nbsp;then&nbsp;add&nbsp;the&nbsp;node&nbsp;for<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;its&nbsp;endpoint&nbsp;to&nbsp;the&nbsp;tree&nbsp;as&nbsp;an&nbsp;outer&nbsp;node.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;The&nbsp;endpoint&nbsp;has&nbsp;the&nbsp;edge&nbsp;start&nbsp;as&nbsp;a&nbsp;parent&nbsp;and&nbsp;the&nbsp;same<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;root&nbsp;as&nbsp;its&nbsp;parent.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forest.put(curr.end,&nbsp;<span style="color: blue">new</span>&nbsp;NodeInformation&lt;T&gt;(curr.start,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startInfo.treeRoot,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">false</span>));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Look&nbsp;up&nbsp;the&nbsp;unique&nbsp;edge&nbsp;that&nbsp;is&nbsp;matched&nbsp;to&nbsp;this&nbsp;node.&nbsp;&nbsp;Its<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;endpoint&nbsp;is&nbsp;the&nbsp;node&nbsp;that&nbsp;will&nbsp;become&nbsp;an&nbsp;outer&nbsp;node&nbsp;of&nbsp;this<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;tree.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T&nbsp;endpoint&nbsp;=&nbsp;m.edgesFrom(curr.end).iterator().next();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forest.put(endpoint,&nbsp;<span style="color: blue">new</span>&nbsp;NodeInformation&lt;T&gt;(curr.end,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startInfo.treeRoot,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">true</span>));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Add&nbsp;all&nbsp;outgoing&nbsp;edges&nbsp;from&nbsp;this&nbsp;endpoint&nbsp;to&nbsp;the&nbsp;work<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;list.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">for</span>&nbsp;(T&nbsp;fringeNode:&nbsp;g.edgesFrom(endpoint))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;worklist.add(<span style="color: blue">new</span>&nbsp;Edge&lt;T&gt;(endpoint,&nbsp;fringeNode));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;If&nbsp;we&nbsp;reach&nbsp;here,&nbsp;it&nbsp;means&nbsp;that&nbsp;we've&nbsp;constructed&nbsp;a&nbsp;maximum&nbsp;forest<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;without&nbsp;finding&nbsp;any&nbsp;augmenting&nbsp;paths.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">return</span>&nbsp;<span style="color: blue">null</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: teal">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Given&nbsp;a&nbsp;forest&nbsp;of&nbsp;alternating&nbsp;trees&nbsp;and&nbsp;an&nbsp;edge&nbsp;forming&nbsp;a&nbsp;blossom&nbsp;in<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;one&nbsp;of&nbsp;those&nbsp;trees,&nbsp;returns&nbsp;information&nbsp;about&nbsp;the&nbsp;blossom.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;forest&nbsp;The&nbsp;alternating&nbsp;forest.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;edge&nbsp;The&nbsp;edge&nbsp;that&nbsp;created&nbsp;a&nbsp;cycle.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;A&nbsp;Blossom&nbsp;struct&nbsp;holding&nbsp;information&nbsp;about&nbsp;then&nbsp;blossom.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">private</span>&nbsp;<span style="color: blue">static</span>&nbsp;&lt;T&gt;&nbsp;Blossom&lt;T&gt;&nbsp;findBlossom(Map&lt;T,&nbsp;NodeInformation&lt;T&gt;&gt;&nbsp;forest,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Edge&lt;T&gt;&nbsp;edge)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;We&nbsp;need&nbsp;to&nbsp;locate&nbsp;the&nbsp;root&nbsp;of&nbsp;the&nbsp;blossom,&nbsp;which&nbsp;is&nbsp;the&nbsp;lowest<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;common&nbsp;ancestor&nbsp;of&nbsp;the&nbsp;two&nbsp;nodes&nbsp;at&nbsp;the&nbsp;endpoint&nbsp;of&nbsp;each&nbsp;edge.&nbsp;&nbsp;To<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;do&nbsp;this,&nbsp;we'll&nbsp;walk&nbsp;up&nbsp;from&nbsp;each&nbsp;node&nbsp;to&nbsp;the&nbsp;root,&nbsp;storing&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;paths&nbsp;we&nbsp;find.&nbsp;&nbsp;We&nbsp;will&nbsp;then&nbsp;look&nbsp;for&nbsp;the&nbsp;last&nbsp;node&nbsp;that's&nbsp;common<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;to&nbsp;both&nbsp;paths.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LinkedList&lt;T&gt;&nbsp;onePath&nbsp;=&nbsp;<span style="color: blue">new</span>&nbsp;LinkedList&lt;T&gt;(),&nbsp;twoPath&nbsp;=&nbsp;<span style="color: blue">new</span>&nbsp;LinkedList&lt;T&gt;();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">for</span>&nbsp;(T&nbsp;node&nbsp;=&nbsp;edge.start;&nbsp;node&nbsp;!=&nbsp;<span style="color: blue">null</span>;&nbsp;node&nbsp;=&nbsp;forest.get(node).parent)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onePath.addFirst(node);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">for</span>&nbsp;(T&nbsp;node&nbsp;=&nbsp;edge.end;&nbsp;node&nbsp;!=&nbsp;<span style="color: blue">null</span>;&nbsp;node&nbsp;=&nbsp;forest.get(node).parent)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;twoPath.addFirst(node);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Now&nbsp;that&nbsp;we&nbsp;have&nbsp;that&nbsp;paths,&nbsp;continue&nbsp;walking&nbsp;forward&nbsp;in&nbsp;them&nbsp;until<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;we&nbsp;find&nbsp;a&nbsp;mismatch.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">int</span>&nbsp;mismatch&nbsp;=&nbsp;<span style="color: orange">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">for</span>&nbsp;(;&nbsp;mismatch&nbsp;&lt;&nbsp;onePath.size()&nbsp;&amp;&amp;&nbsp;mismatch&nbsp;&lt;&nbsp;twoPath.size();&nbsp;++mismatch)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">if</span>&nbsp;(onePath.get(mismatch)&nbsp;!=&nbsp;twoPath.get(mismatch))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">break</span>;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;At&nbsp;this&nbsp;point,&nbsp;we&nbsp;know&nbsp;that&nbsp;the&nbsp;mismatch&nbsp;occurs&nbsp;at&nbsp;index&nbsp;right<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;before&nbsp;mismatch.&nbsp;&nbsp;Because&nbsp;both&nbsp;nodes&nbsp;are&nbsp;part&nbsp;of&nbsp;the&nbsp;same&nbsp;tree,&nbsp;we<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;know&nbsp;that&nbsp;they&nbsp;have&nbsp;the&nbsp;same&nbsp;root,&nbsp;and&nbsp;so&nbsp;the&nbsp;mismatch&nbsp;index&nbsp;is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;nonzero.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;From&nbsp;here,&nbsp;we&nbsp;can&nbsp;recover&nbsp;the&nbsp;cycles&nbsp;by&nbsp;walking&nbsp;down&nbsp;from&nbsp;the&nbsp;root<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;to&nbsp;the&nbsp;first&nbsp;node,&nbsp;across&nbsp;the&nbsp;indicated&nbsp;edge,&nbsp;and&nbsp;then&nbsp;back&nbsp;up&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;path&nbsp;from&nbsp;the&nbsp;second&nbsp;node&nbsp;to&nbsp;the&nbsp;cycle.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;T&gt;&nbsp;cycle&nbsp;=&nbsp;<span style="color: blue">new</span>&nbsp;ArrayList&lt;T&gt;();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">for</span>&nbsp;(<span style="color: blue">int</span>&nbsp;i&nbsp;=&nbsp;mismatch&nbsp;-&nbsp;<span style="color: orange">1</span>;&nbsp;i&nbsp;&lt;&nbsp;onePath.size();&nbsp;++i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cycle.add(onePath.get(i));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">for</span>&nbsp;(<span style="color: blue">int</span>&nbsp;i&nbsp;=&nbsp;twoPath.size()&nbsp;-&nbsp;<span style="color: orange">1</span>;&nbsp;i&nbsp;&gt;=&nbsp;mismatch&nbsp;-&nbsp;<span style="color: orange">1</span>;&nbsp;--i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cycle.add(twoPath.get(i));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">return</span>&nbsp;<span style="color: blue">new</span>&nbsp;Blossom&lt;T&gt;(onePath.get(mismatch&nbsp;-&nbsp;<span style="color: orange">1</span>),&nbsp;cycle,&nbsp;<span style="color: blue">new</span>&nbsp;HashSet&lt;T&gt;(cycle));<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: teal">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Given&nbsp;a&nbsp;graph&nbsp;and&nbsp;a&nbsp;blossom,&nbsp;returns&nbsp;the&nbsp;contraction&nbsp;of&nbsp;the&nbsp;graph&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;around&nbsp;that&nbsp;blossom.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;g&nbsp;The&nbsp;graph&nbsp;to&nbsp;contract.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;blossom&nbsp;The&nbsp;set&nbsp;of&nbsp;nodes&nbsp;in&nbsp;the&nbsp;blossom.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;The&nbsp;contraction&nbsp;g&nbsp;/&nbsp;blossom.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">private</span>&nbsp;<span style="color: blue">static</span>&nbsp;&lt;T&gt;&nbsp;UndirectedGraph&lt;T&gt;&nbsp;contractGraph(UndirectedGraph&lt;T&gt;&nbsp;g,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Blossom&lt;T&gt;&nbsp;blossom)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;The&nbsp;contraction&nbsp;of&nbsp;the&nbsp;graph&nbsp;is&nbsp;the&nbsp;modified&nbsp;graph&nbsp;where:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;1.&nbsp;All&nbsp;nodes&nbsp;in&nbsp;the&nbsp;blossom&nbsp;are&nbsp;removed.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;2.&nbsp;There&nbsp;is&nbsp;a&nbsp;new&nbsp;node,&nbsp;the&nbsp;pseudonode.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;3.&nbsp;All&nbsp;edges&nbsp;between&nbsp;nodes&nbsp;in&nbsp;the&nbsp;blossom&nbsp;are&nbsp;removed.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;4.&nbsp;All&nbsp;edges&nbsp;between&nbsp;nodes&nbsp;out&nbsp;of&nbsp;the&nbsp;blossom&nbsp;and&nbsp;nodes&nbsp;in&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;blossom&nbsp;are&nbsp;replaced&nbsp;by&nbsp;an&nbsp;edge&nbsp;to&nbsp;the&nbsp;pseudonode.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UndirectedGraph&lt;T&gt;&nbsp;result&nbsp;=&nbsp;<span style="color: blue">new</span>&nbsp;UndirectedGraph&lt;T&gt;();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Begin&nbsp;by&nbsp;adding&nbsp;all&nbsp;nodes&nbsp;not&nbsp;in&nbsp;the&nbsp;blossom.&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">for</span>&nbsp;(T&nbsp;node:&nbsp;g)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">if</span>&nbsp;(!blossom.nodes.contains(node))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.addNode(node);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Add&nbsp;the&nbsp;pseudonode&nbsp;in.&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.addNode(blossom.root);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Add&nbsp;each&nbsp;edge&nbsp;in,&nbsp;adjusting&nbsp;the&nbsp;endpoint&nbsp;as&nbsp;appropriate.&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">for</span>&nbsp;(T&nbsp;node:&nbsp;g)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Skip&nbsp;nodes&nbsp;in&nbsp;the&nbsp;blossom;&nbsp;they're&nbsp;not&nbsp;included&nbsp;in&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;contracted&nbsp;graph.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">if</span>&nbsp;(blossom.nodes.contains(node))&nbsp;<span style="color: blue">continue</span>;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Explore&nbsp;all&nbsp;nodes&nbsp;connected&nbsp;to&nbsp;this&nbsp;one.&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">for</span>&nbsp;(T&nbsp;endpoint:&nbsp;g.edgesFrom(node))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;If&nbsp;this&nbsp;endpoint&nbsp;is&nbsp;in&nbsp;the&nbsp;blossom,&nbsp;pretend&nbsp;that&nbsp;it's&nbsp;now<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;an&nbsp;edge&nbsp;to&nbsp;the&nbsp;pseudonode.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">if</span>&nbsp;(blossom.nodes.contains(endpoint))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endpoint&nbsp;=&nbsp;blossom.root;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Add&nbsp;the&nbsp;edge&nbsp;to&nbsp;the&nbsp;graph,&nbsp;accounting&nbsp;for&nbsp;the&nbsp;fact&nbsp;that&nbsp;it<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;might&nbsp;now&nbsp;be&nbsp;transformed.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.addEdge(node,&nbsp;endpoint);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">return</span>&nbsp;result;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: teal">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Given&nbsp;an&nbsp;alternating&nbsp;path&nbsp;in&nbsp;a&nbsp;graph&nbsp;formed&nbsp;by&nbsp;the&nbsp;contraction&nbsp;of<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;a&nbsp;blossom&nbsp;into&nbsp;a&nbsp;pseudonode,&nbsp;along&nbsp;with&nbsp;the&nbsp;alternating&nbsp;forest&nbsp;in&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;original&nbsp;graph,&nbsp;returns&nbsp;a&nbsp;new&nbsp;alternating&nbsp;path&nbsp;in&nbsp;the&nbsp;original&nbsp;graph<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;formed&nbsp;by&nbsp;expanding&nbsp;the&nbsp;path&nbsp;if&nbsp;it&nbsp;goes&nbsp;through&nbsp;a&nbsp;pseudonode.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;path&nbsp;The&nbsp;path&nbsp;in&nbsp;the&nbsp;contracted&nbsp;graph.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;g&nbsp;The&nbsp;uncontracted&nbsp;graph.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;forest&nbsp;The&nbsp;alternating&nbsp;forest&nbsp;of&nbsp;the&nbsp;original&nbsp;graph.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;blossom&nbsp;The&nbsp;blossom&nbsp;that&nbsp;was&nbsp;contracted.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;pseudonode&nbsp;The&nbsp;pseudonode&nbsp;representing&nbsp;the&nbsp;blossom&nbsp;in&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contracted&nbsp;graph.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;An&nbsp;alternating&nbsp;path&nbsp;in&nbsp;the&nbsp;original&nbsp;graph.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">private</span>&nbsp;<span style="color: blue">static</span>&nbsp;&lt;T&gt;&nbsp;List&lt;T&gt;&nbsp;expandPath(List&lt;T&gt;&nbsp;path,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UndirectedGraph&lt;T&gt;&nbsp;g,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map&lt;T,&nbsp;NodeInformation&lt;T&gt;&gt;&nbsp;forest,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Blossom&lt;T&gt;&nbsp;blossom)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Any&nbsp;path&nbsp;in&nbsp;the&nbsp;contracted&nbsp;graph&nbsp;will&nbsp;have&nbsp;at&nbsp;most&nbsp;one&nbsp;instance&nbsp;of<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;the&nbsp;blossom's&nbsp;pseudonode&nbsp;in&nbsp;it.&nbsp;&nbsp;This&nbsp;node&nbsp;will&nbsp;have&nbsp;at&nbsp;most&nbsp;one<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;dotted&nbsp;(unmatched)&nbsp;edge&nbsp;incident&nbsp;to&nbsp;it&nbsp;and&nbsp;one&nbsp;solid&nbsp;(matched)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;edge.&nbsp;&nbsp;When&nbsp;expanding&nbsp;the&nbsp;node,&nbsp;the&nbsp;solid&nbsp;edge&nbsp;will&nbsp;end&nbsp;up&nbsp;incident<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;to&nbsp;the&nbsp;root&nbsp;of&nbsp;the&nbsp;blossom,&nbsp;and&nbsp;the&nbsp;dotted&nbsp;edge&nbsp;will&nbsp;leave&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;blossom&nbsp;through&nbsp;some&nbsp;edge.&nbsp;&nbsp;The&nbsp;challenge&nbsp;of&nbsp;this&nbsp;function&nbsp;is&nbsp;as<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;follows:&nbsp;given&nbsp;a&nbsp;path&nbsp;that&nbsp;may&nbsp;or&nbsp;may&nbsp;not&nbsp;pass&nbsp;through&nbsp;this<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;blossom,&nbsp;find&nbsp;some&nbsp;edge&nbsp;leaving&nbsp;the&nbsp;blossom&nbsp;to&nbsp;the&nbsp;next&nbsp;node&nbsp;in&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;chain,&nbsp;then&nbsp;route&nbsp;the&nbsp;path&nbsp;through&nbsp;the&nbsp;blossom&nbsp;in&nbsp;such&nbsp;a&nbsp;way&nbsp;that<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;the&nbsp;path&nbsp;is&nbsp;alternating.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;To&nbsp;do&nbsp;this,&nbsp;we'll&nbsp;make&nbsp;a&nbsp;simplifying&nbsp;assumption&nbsp;that&nbsp;the&nbsp;path&nbsp;is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;oriented&nbsp;such&nbsp;that&nbsp;as&nbsp;we&nbsp;start&nbsp;from&nbsp;the&nbsp;front&nbsp;and&nbsp;walk&nbsp;toward&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;end,&nbsp;we&nbsp;enter&nbsp;the&nbsp;blossom's&nbsp;pseudonode&nbsp;through&nbsp;a&nbsp;solid&nbsp;edge&nbsp;and<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;leave&nbsp;through&nbsp;a&nbsp;dotted&nbsp;edge.&nbsp;&nbsp;Dotted&nbsp;edges&nbsp;are&nbsp;at&nbsp;indices&nbsp;(0,&nbsp;1),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;(2,&nbsp;3),&nbsp;...,&nbsp;(2i,&nbsp;2i&nbsp;+&nbsp;1),&nbsp;and&nbsp;so&nbsp;we're&nbsp;going&nbsp;to&nbsp;want&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;pseudonode&nbsp;to&nbsp;appear&nbsp;at&nbsp;an&nbsp;even&nbsp;index.&nbsp;&nbsp;Because&nbsp;the&nbsp;path&nbsp;is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;alternating,&nbsp;there's&nbsp;an&nbsp;odd&nbsp;number&nbsp;of&nbsp;edges&nbsp;in&nbsp;the&nbsp;path,&nbsp;and<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;therefore&nbsp;our&nbsp;path&nbsp;has&nbsp;an&nbsp;even&nbsp;number&nbsp;of&nbsp;nodes.&nbsp;&nbsp;Consequently,&nbsp;if<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;the&nbsp;pseudonode&nbsp;exists&nbsp;in&nbsp;the&nbsp;path,&nbsp;then&nbsp;either&nbsp;it's&nbsp;at&nbsp;an&nbsp;even<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;index&nbsp;(in&nbsp;which&nbsp;case&nbsp;our&nbsp;assumption&nbsp;holds),&nbsp;or&nbsp;its&nbsp;at&nbsp;an&nbsp;odd&nbsp;index<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;(in&nbsp;which&nbsp;case&nbsp;we&nbsp;need&nbsp;to&nbsp;reverse&nbsp;our&nbsp;list,&nbsp;converting&nbsp;the&nbsp;odd<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;index&nbsp;into&nbsp;an&nbsp;even&nbsp;index).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">int</span>&nbsp;index&nbsp;=&nbsp;path.indexOf(blossom.root);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;If&nbsp;the&nbsp;node&nbsp;doesn't&nbsp;exist&nbsp;at&nbsp;all,&nbsp;our&nbsp;path&nbsp;is&nbsp;valid.&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">if</span>&nbsp;(index&nbsp;==&nbsp;<span style="color: orange">-1</span>)&nbsp;<span style="color: blue">return</span>&nbsp;path;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;If&nbsp;the&nbsp;node&nbsp;is&nbsp;at&nbsp;an&nbsp;odd&nbsp;index,&nbsp;reverse&nbsp;the&nbsp;list&nbsp;and&nbsp;recompute&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;index.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">if</span>&nbsp;(index&nbsp;%&nbsp;<span style="color: orange">2</span>&nbsp;==&nbsp;<span style="color: orange">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;=&nbsp;reversePath(path);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Now&nbsp;that&nbsp;we&nbsp;have&nbsp;the&nbsp;pseudonode&nbsp;at&nbsp;an&nbsp;even&nbsp;index&nbsp;(the&nbsp;start&nbsp;of&nbsp;a<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;dotted&nbsp;edge),&nbsp;we&nbsp;can&nbsp;start&nbsp;expanding&nbsp;out&nbsp;the&nbsp;path.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;T&gt;&nbsp;result&nbsp;=&nbsp;<span style="color: blue">new</span>&nbsp;ArrayList&lt;T&gt;();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">for</span>&nbsp;(<span style="color: blue">int</span>&nbsp;i&nbsp;=&nbsp;<span style="color: orange">0</span>;&nbsp;i&nbsp;&lt;&nbsp;path.size();&nbsp;++i)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Look&nbsp;at&nbsp;the&nbsp;current&nbsp;node.&nbsp;&nbsp;If&nbsp;it's&nbsp;not&nbsp;the&nbsp;pseudonode,&nbsp;then&nbsp;add<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;it&nbsp;into&nbsp;the&nbsp;resulting&nbsp;path&nbsp;with&nbsp;no&nbsp;modifications.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">if</span>&nbsp;(path.get(i)&nbsp;!=&nbsp;blossom.root)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.add(path.get(i));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Otherwise,&nbsp;we&nbsp;are&nbsp;looking&nbsp;at&nbsp;the&nbsp;pseudonode,&nbsp;which&nbsp;must&nbsp;be&nbsp;at<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;the&nbsp;start&nbsp;of&nbsp;a&nbsp;dotted&nbsp;edge.&nbsp;&nbsp;We&nbsp;need&nbsp;to&nbsp;look&nbsp;at&nbsp;the&nbsp;next&nbsp;node<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;in&nbsp;the&nbsp;path&nbsp;to&nbsp;determine&nbsp;how&nbsp;to&nbsp;expand&nbsp;this&nbsp;pseudonode.&nbsp;&nbsp;In<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;particular,&nbsp;we&nbsp;need&nbsp;to&nbsp;find&nbsp;some&nbsp;node&nbsp;in&nbsp;the&nbsp;cycle&nbsp;that&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;next&nbsp;node&nbsp;in&nbsp;the&nbsp;path&nbsp;connects&nbsp;to,&nbsp;then&nbsp;need&nbsp;to&nbsp;route&nbsp;the&nbsp;path<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;around&nbsp;the&nbsp;cycle&nbsp;to&nbsp;that&nbsp;node.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Add&nbsp;the&nbsp;blossom's&nbsp;root&nbsp;to&nbsp;the&nbsp;path,&nbsp;since&nbsp;any&nbsp;path&nbsp;entering<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;the&nbsp;blossom&nbsp;on&nbsp;a&nbsp;solid&nbsp;edge&nbsp;must&nbsp;come&nbsp;in&nbsp;here.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.add(blossom.root);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Find&nbsp;some&nbsp;node&nbsp;in&nbsp;the&nbsp;cycle&nbsp;with&nbsp;an&nbsp;edge&nbsp;to&nbsp;the&nbsp;next&nbsp;node<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;in&nbsp;the&nbsp;path.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T&nbsp;outNode&nbsp;=&nbsp;findNodeLeavingCycle(g,&nbsp;blossom,&nbsp;path.get(i&nbsp;+&nbsp;<span style="color: orange">1</span>));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Look&nbsp;up&nbsp;where&nbsp;this&nbsp;node&nbsp;is&nbsp;in&nbsp;the&nbsp;cycle.&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">int</span>&nbsp;outIndex&nbsp;=&nbsp;blossom.cycle.indexOf(outNode);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;When&nbsp;expanding&nbsp;out&nbsp;this&nbsp;path&nbsp;around&nbsp;the&nbsp;cycle,&nbsp;we&nbsp;need&nbsp;to<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;ensure&nbsp;that&nbsp;the&nbsp;path&nbsp;we&nbsp;take&nbsp;ends&nbsp;by&nbsp;following&nbsp;a&nbsp;solid<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;edge,&nbsp;since&nbsp;the&nbsp;next&nbsp;edge&nbsp;that&nbsp;we'll&nbsp;be&nbsp;taking&nbsp;is&nbsp;dashed.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;There&nbsp;are&nbsp;two&nbsp;possible&nbsp;ways&nbsp;to&nbsp;navigate&nbsp;the&nbsp;cycle&nbsp;-&nbsp;one<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;going&nbsp;clockwise&nbsp;and&nbsp;one&nbsp;going&nbsp;counterclockwise.&nbsp;&nbsp;If&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;index&nbsp;of&nbsp;the&nbsp;outgoing&nbsp;node&nbsp;is&nbsp;even,&nbsp;then&nbsp;the&nbsp;path&nbsp;through<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;the&nbsp;cycle&nbsp;in&nbsp;the&nbsp;forward&nbsp;direction&nbsp;will&nbsp;end&nbsp;by&nbsp;following&nbsp;a<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;solid&nbsp;edge.&nbsp;&nbsp;If&nbsp;it's&nbsp;odd,&nbsp;then&nbsp;the&nbsp;path&nbsp;through&nbsp;the&nbsp;cycle<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;in&nbsp;the&nbsp;reverse&nbsp;direction&nbsp;ends&nbsp;with&nbsp;an&nbsp;outgoing&nbsp;edge.&nbsp;&nbsp;We'll<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;choose&nbsp;which&nbsp;way&nbsp;to&nbsp;go&nbsp;accordingly.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;The&nbsp;cycle&nbsp;we've&nbsp;stored&nbsp;has&nbsp;the&nbsp;root&nbsp;of&nbsp;the&nbsp;blossom&nbsp;at<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;either&nbsp;endpoint,&nbsp;and&nbsp;so&nbsp;we'll&nbsp;skip&nbsp;over&nbsp;it&nbsp;in&nbsp;this<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;iteration.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">int</span>&nbsp;start&nbsp;=&nbsp;(outIndex&nbsp;%&nbsp;<span style="color: orange">2</span>&nbsp;==&nbsp;<span style="color: orange">0</span>)?&nbsp;<span style="color: orange">1</span>&nbsp;:&nbsp;blossom.cycle.size()&nbsp;-&nbsp;<span style="color: orange">2</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">int</span>&nbsp;step&nbsp;&nbsp;=&nbsp;(outIndex&nbsp;%&nbsp;<span style="color: orange">2</span>&nbsp;==&nbsp;<span style="color: orange">0</span>)?&nbsp;<span style="color: orange">+1</span>&nbsp;:&nbsp;<span style="color: orange">-1</span>;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Walk&nbsp;along&nbsp;the&nbsp;cycle&nbsp;accordingly.&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">for</span>&nbsp;(<span style="color: blue">int</span>&nbsp;k&nbsp;=&nbsp;start;&nbsp;k&nbsp;!=&nbsp;step;&nbsp;k&nbsp;+=&nbsp;step)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.add(blossom.cycle.get(k));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">return</span>&nbsp;result;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: teal">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Given&nbsp;a&nbsp;path,&nbsp;returns&nbsp;the&nbsp;path&nbsp;formed&nbsp;by&nbsp;reversing&nbsp;the&nbsp;order&nbsp;of&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;nodes&nbsp;in&nbsp;that&nbsp;path.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;path&nbsp;The&nbsp;path&nbsp;to&nbsp;reverse.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;The&nbsp;reverse&nbsp;of&nbsp;that&nbsp;path.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">private</span>&nbsp;<span style="color: blue">static</span>&nbsp;&lt;T&gt;&nbsp;List&lt;T&gt;&nbsp;reversePath(List&lt;T&gt;&nbsp;path)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;T&gt;&nbsp;result&nbsp;=&nbsp;<span style="color: blue">new</span>&nbsp;ArrayList&lt;T&gt;();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Visit&nbsp;the&nbsp;path&nbsp;in&nbsp;the&nbsp;reverse&nbsp;order.&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">for</span>&nbsp;(<span style="color: blue">int</span>&nbsp;i&nbsp;=&nbsp;path.size()&nbsp;-&nbsp;<span style="color: orange">1</span>;&nbsp;i&nbsp;&gt;=&nbsp;<span style="color: orange">0</span>;&nbsp;--i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.add(path.get(i));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">return</span>&nbsp;result;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: teal">/**<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Given&nbsp;a&nbsp;graph,&nbsp;a&nbsp;blossom&nbsp;in&nbsp;that&nbsp;graph,&nbsp;and&nbsp;a&nbsp;node&nbsp;in&nbsp;that&nbsp;graph,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;returns&nbsp;a&nbsp;node&nbsp;in&nbsp;the&nbsp;blossom&nbsp;that&nbsp;has&nbsp;an&nbsp;outgoing&nbsp;edge&nbsp;to&nbsp;that&nbsp;node.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;If&nbsp;multiple&nbsp;nodes&nbsp;in&nbsp;the&nbsp;blossom&nbsp;have&nbsp;such&nbsp;an&nbsp;edge,&nbsp;one&nbsp;of&nbsp;them&nbsp;is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;chosen&nbsp;arbitrarily.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;g&nbsp;The&nbsp;graph&nbsp;in&nbsp;which&nbsp;the&nbsp;cycle&nbsp;occurs.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;blossom&nbsp;The&nbsp;blossom&nbsp;in&nbsp;that&nbsp;graph.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;node&nbsp;The&nbsp;node&nbsp;outside&nbsp;of&nbsp;the&nbsp;blossom.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;Some&nbsp;node&nbsp;in&nbsp;the&nbsp;blossom&nbsp;with&nbsp;an&nbsp;edge&nbsp;in&nbsp;g&nbsp;to&nbsp;the&nbsp;indicated<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">private</span>&nbsp;<span style="color: blue">static</span>&nbsp;&lt;T&gt;&nbsp;T&nbsp;findNodeLeavingCycle(UndirectedGraph&lt;T&gt;&nbsp;g,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Blossom&lt;T&gt;&nbsp;blossom,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T&nbsp;node)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;Check&nbsp;each&nbsp;node&nbsp;in&nbsp;the&nbsp;blossom&nbsp;for&nbsp;a&nbsp;matching&nbsp;edge.&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">for</span>&nbsp;(T&nbsp;cycleNode:&nbsp;blossom.nodes)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">if</span>&nbsp;(g.edgeExists(cycleNode,&nbsp;node))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">return</span>&nbsp;cycleNode;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: green">/*&nbsp;If&nbsp;we&nbsp;got&nbsp;here,&nbsp;something&nbsp;is&nbsp;wrong&nbsp;because&nbsp;the&nbsp;node&nbsp;in&nbsp;question<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;should&nbsp;have&nbsp;some&nbsp;edge&nbsp;into&nbsp;it.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: blue">throw</span>&nbsp;<span style="color: blue">new</span>&nbsp;AssertionError(<span style="color: orange">&quot;Could&nbsp;not&nbsp;find&nbsp;an&nbsp;edge&nbsp;out&nbsp;of&nbsp;the&nbsp;blossom.&quot;</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}  </body>
</html>
